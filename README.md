This project is a coding kata meant to practice foundational design skills with a well-understood task. The kata here is to implement a classic example: Conway's Game of Life [ https://infogalactic.com/info/Conway%27s_Game_of_Life ]. Design goals for this particular implementation are twofold. One is to make use of and refine an experimental Windows GUI library. The other is to practice API design that fits the priciple: "Easy to use; difficult to misuse." Success in this realm would mean that code is highly expressive with few lines/arguments, the interface guides consumers toward proper usage, and consumers find the library intuitive to use. Pathways to this goal include using strong value types to prevent argument mixups, intelligent function overloads that adjust behavior to the surrounding context, implicit converstions that seemlessly tie related concepts, and objects tailor-fit to the expected design tasks.

One of the inspirations for this ongoing focus on interface design is a 2020 conference talk by Matt Godbolt: Correct by Construction [ https://www.youtube.com/watch?v=nLSm3Haxz0I ].

Instructions:

Click cell to toggle dead/alive
Cell click pauses progression to enable editing
Return-key toggles Play/Pause

Design Features:

The WINDOW library is meant to be a lightweight wrapper for foundational Win32 C-style API calls that is perfectly interoperable with the official API. Many WINDOW functions simply provide a more appealing Object-Oriented interface that delegates straight to C-style functions. This interface typically provides much greater clarity & concision as compared to the equivalent C-style calls. Function calls tend to use fewer arguments, arguments are difficult to mix up, and many functions return a reference back to the WINDOW to allow chaining of commands. Custom structs are used to avoid argument mixups, such as X-position, Y-position, Width, & Height. To top it all off, the WINDOW object implicitly converts to a window handle, which allows it to be passed into any function that takes a HWND. This library can thus be brought into an existing code base for even a few lines of code without requiring any GUI paradigm change.

In a similar vein, this project inspired the supporting PAINT_TOKEN class. This token relieves a burden of programmer discipline when using Windows paint functions. The official API requires the consumer to take responsibility for the set up & tear down of paint operations. By creating a PAINT_TOKEN, a developer can enlist the compiler to generate these calls on his behalf by capitalizing on object lifetime. Construction of a new token is only accessible through WINDOW.BeginPaint(). The token then serves as an implicit promise that the associated window is already initialized and ready for drawing operations. Tokens are to be passed into any drawing function that takes an HDC. They convert implicitly, so they are perfectly interchangable with existing code. Once drawing is complete, the developer can let the token fall out of scope and the destructor handles the cleanup. Tokens are move-only to help minimize misuse and communicates the importance of the object lifetime. (Even so, this could be abused with multiple calls to .BeginPaint() or a premature call to the Win32 API EndPaint(HWND), which should stand out as a consumer-error.)

The cells have several layers of utility meant to make facilitate clean, correct code. First, there are set lists of all cell positions and all of their neighbors. These make it easier to iterate through all relevant cells with a simple range-for loop rather than complicated nesting of for-loops. One could easily imagine looping through cell X-position, cell Y-position, neighbor X-position, & neighbor Y-position... four layer deep to update all cells and querey all neighbors. This creates simpler code and less calculation per loop. Second, these lists are given some container-like access. They support the bracket operator to access elements (decomposing a single position into row, column elements) and supporting .begin() and .end() operations as relevant to support a ranged-for loop. Third, the PROXY_CELL class gives consumers indirect access to CELLs while still retaining control over invariants. (Most relevant here is informing their neighbors when their life state changes.)

This program also begins to extend the possibilities of the base game by introducing extended life-state tracking of cells. Instead of simply being dead/alive, cells are now tracked based upon three generations (1 past, present, 1 future) of dead/alive. Conceptually, this tells consumers much more about where a cell has been and where it's going. This introduces new options for visualization built into the library rather than requiring consumers to track & compare each cell on their own. Practically, this is achieved with bitmasking of enums. There are three foundational states (WAS_ALIVE, ALIVE, WILL_LIVE), which then expand to 8 (=2^3) foundational and composite states. Scoped enums are preferred since they avoid problems of unintentional misuse, however this introduced a new issue for bitmask operations. The lack of implicit conversion to an integral type interferes with exactly the sort of bitwise operations desired here. There must be an explicit cast both to and from to achieve the desired result. Four utility functions were then created to facilitate this. They were created as a generic template added to the Utilities.h file for their universal applicability. They hide the verbose casting back & forth, while also perfectly type-matching with template parameters. Note also that this issue may be trivial in C++20 with the new "using enum" directive, but it is too soon to expect consistent support of all the new language features.

Possible Changes:

First, the PROXY_CELL may be reconsidered. It seems to make sense to keep the CELL as lean as possible. There's no need to add in extra information like the position or a reference back to its owning TIME_SLICE. That said, working through the proxy to maintain the neighbor count interferes with prallel calculation, which would be increasingly relevant for larger grids. This parallelism was already considered in a few other design choices as outlined below. That said, the proxy pattern may still be of use. The consumer can still "hold on to" a cell while the library producer can change the data tracking under the hood. In particular, splitting out the life-state and neighbor count will help get back to the original parallel computation model imagined.

Second, performance ought to be measured for various computational models. While performance is not a core objective here, it certainly is a design consideration and design choices can facilitate or interfere with that. As discussed above, the proxy neighbor tracking introduced a race-condition with the neighbor tally. If two CELLs update the same neighbor at the same time, they can collide and create an incorrect neighbor count in the affected CELL. This can be fixed by performing the calculation in two steps. All life-states are calculated first, then all neighbor counts are calculated from this result. This would require some modest changes in how the underlying data is organized, but may be well worth while if the performance gains are sufficient. Further, there may be other ways to organize or calculate the data that will be more or less efficient. For example, two vectors of smaller items (i.e. cellStatus vector<LIFE_STATE> and neighborCount vector<int>) would allow more items to be pulled into the processor cache at a time, potentially hastening calculations. The tradeoffs cannot be known for certain without measurement. (Update: Calculation changed to allow unsequenced parallel execution of core computation.)

Third, UI/UX can be improved. Again, this is not a core objective, but certainly has relevance. The whole point of LIFE_HISTORY is to track the various TIME_SLICEs, which becomes relevant once the user can navigate forward/backward through time. The library producer then needs to decide how to track these changes. The current thinking is that any computed generation should be preserved as constant to allow backward verification. Any user edits then get tracked by inserting a new manual slice that clearly indicates a potential break in the life history invariants. That said, this may make it more confusing to tell what a "generation" truly means as there can be generations where the life state contains manual changes in place of life progression. This may be a case where the features need to be developed to get a better sense of what sort of design would best support that.

Further Work:

1. Make the "game" progress based upon a timer rather than a keystroke. Add Play/Pause button to support this. Editing a cell automatically pauses the game to ensure consistent calculations.

2. <s>Add (optional?) more detailed color codes. It might be helpful for users to be able to see which cells are stable, about to grow, recently grown(?), about to die, or recently dead. Packed flags can be used to store multiple overlapping states in the same variable to facilitate this. A logical color scheme would be needed to communcate this. Color scales might coincide with the packed flags in a way that would be sensible to users. For example RBG values of 0 or 255 could correspond to the flags alive/dead, will grow/stable, will die/stable.</s>

3. Performance upgrades as discussed above based upon testing.

4. Further GUI library upgrades as needs arise.